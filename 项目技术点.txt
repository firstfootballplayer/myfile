异步日志库：
日志分等级，多线程服务程序异步日志是必需的，如果在网络io线程或业务线程中直接往磁盘写入的话，写操作偶尔可能阻塞时间比较长，磁盘转动寻址等操作比较耗时，从而使网络框架或业务处理的整体性能下降。
日志库维护两块缓冲区4m，A与B，前台将日志消息写入buffer A中，后台负责将buffer B中的数据写入日志文件。当buffer A写满之后或者每隔3秒，交换A与B（用交换指针实现），让后端将buffer A中的数据写入文件，
而前端往buffer B中写入新的日志（buffer用字节数确定有效区间）。如此往复。前台将多个日志消息写入到一大块缓存后传送给后端，用两个buffer的好处是在写入日志消息的时候不必等待磁盘文件操作，
也避免每条消息都唤醒后端日志的线程。相当于批处理，减少了线程唤醒的频率，降低了开销。

线程池：
线程池本质上是一个生产者-消费者问题，外部线程可以向线程池中的任务队列添加任务同时唤醒线程队列中的线程，它相当于“生产者”；线程池的线程就相当于“消费者”
线程池中包括，function对象相当于是任务的回调，一个vector容器里面存放线程，一个队列deque用于放入任务，两个条件变量，一个用于任务队列非空即有任务时使用，另一个在任务队列非满即可以推入任务时使用
在生成一个线程池对象后可以设置线程池线程的个数，和任务队列的上限。然后开启线程池，制造多个线程，这些线程运行在一个无限循环里，刚开始都阻塞在任务队列非空的条件变量上，等到有任务放入任务队列后唤醒
其中一个线程执行任务，执行完后继续阻塞在条件变量上。

核心EventLoop类：
其中包括Poller类这是一个抽象类，主要封装了io复用的监听，更新事件查找激活事件的操作，它可由select poll epoll3个派生类继承，实现多态的调用。
一个vector用于存放激活事件，它的类型是名为channel的类，一个fd对应一个channel，里面有一个fd变量，监听和激活事件类型变量，可读可写的回调函数变量。
用户可以将fd绑定到一个channel对象，调用poller的接口更新要监听的事件，然后设置自己的可读可写回调函数，在EventLoop的poll函数中进行循环，io复用将检测到的激活事件放入激活队列里面，然后依次处理每个激活
的fd。这样基本实现了一个reactor模型，
tcpserver的实现借助上诉技术再进行了封装，TcpServer类包括，一个EventLoop对象，用于在主线程中监听新连接的到来，一个线程池对象，其中的每个线程中都有一个EventLoop对象，它们运行于loop函数即循环，每个
线程都是一个reactor。主线程在建立一个新的连接后，通过roundrobin的方式将新连接绑定到线程池的不同线程上以实现负载均衡，每个tcp连接都有一个tcpconnection对象与之对应，这个类包含了一个channel，同时维护
一块读缓存区可以解决tcp粘包问题，对tcp的读写操作进行了封装。这样就实现了一个tcp服务器，用户可以在服务器运行之前设置自定义的读写回调函数。

buffer类包括使用vector<char>的缓冲区，大小为1k可动态扩容，另外还有一个读索引和写索引变量，当向buffer中写入数据时，写索引往前移动写入的字节数，从buffer中取出数据时读索引往前移动相应字节数，即buffer的
大小减去写索引为剩余的可写缓冲区大小，写索引减去读索引为可读数据大小，当要写入数据大于可写缓冲区大小时，检查整个缓冲区前端的空余空间即读索引的大小能否满足，满足则将数据整体前移到开头的位置，然后更新
读写索引，不满足则动态扩容vector大小

定时器类和最小堆类：用最小堆管理定时器，设置超时时间后，实际时间是当前时间加上超时时间，将定时器放入最小堆后排序，保证根节点的超时时间是最小的，在reactor模型中的逻辑是这样的，首先从堆顶取出元素，
计算出相对时间将此时间作为io复用的参数，io复用返回后，处理到时事件，如果有超时则放入活跃链表中,并从堆中删除，判断活跃链表类型，如果超时为永久事件，则经计算后重新放入到堆中。



在计算机中数据都是按ascii码存储的，而ascii码的128～255之间的值是不可见字符。而在网络上交换数据时，由于不同的设备对字符的处理方式有一些不同，不可见字符就有可能被处理错误，这是不利于传输的。所以就先把
数据先做一个Base64编码，统统变成可见字符，这样出错的可能性就大降低了。
将每三个字节作为一组，一共是24个二进制位。将这24个二进制位分为四组，每个组有6个二进制位。在每组前面加两个00，扩展成32个二进制位，即四个字节。二个字节的情况：将这二个字节的一共16个二进制位，按照上
面的规则，转成三组，最后一组除了前面加两个0以外，后面也要加两个0。这样得到一个三位的Base64编码，再在末尾补上一个"="号。
Base64编码后的文本，会比原文本大出三分之一左右。

MD5输入任意长度的信息，经过处理，输出为128位的信息，MD5不可逆的原因是其是一种散列函数，使用的是hash算法，在计算过程中原文的部分信息是丢失了的。


JSON相对XML来讲，数据格式比较简单，数据的体积小，易于读写，编解码简单，传递的速度更快
XML格式统一，符合标准，JSON的安全性较低；XML比JSON更安全。


作为服务端接收客户端请求（各种机器人控制指令），根据ID将指令下达给对应的机器人，并将机器人返回信息存入数据库同时响应给客户端，所有机器人主动发起TCP长连接至本端并维持心跳机制。 
独立开发C++11服务器，使用Reactor模型，非阻塞IO，epoll多路IO有效提高并发量
使用智能指针，同时使用RAII手法自动获取和释放资源，减少内存泄漏	
基础组件ThreadPool，MemoryPool，TCP应用层缓冲区，异步Log的开发，使用最小堆管理定时器
对IO密集型任务使用固定线程池模型，充分利用多核性能，线程使用遵循one loop per thread原则
采用Round Robin算法，将主线程Accept到的连接分配给线程池，缩短响应时间 
利用STL容器和shared_ptr语义维护应用层心跳机制与客户端保持tcp长连接
使用JSON，XML格式传递网络消息，Base64编解码图片，MD5加密密码

编写SIP服务器处理SIP代理的接入，将底下的设备信息存入数据库，客户端通过HTTP表明要取流的设备id，服务端返回相应的RTSP Url，客户端通过RTSP请求拉流，服务端再通过SIP发起会话后将数据推给客户端
使用状态机和正则表达式解析SIP和RTSP，检查Session，CSeq，Authorization等字段的合法性
向接入的SIP代理查询其管理的SIP设备信息，将相关信息存入MySQL供客户端查询使用
完成对rtp数据的解析并记录相应字段， 将PS或H264数据封装rtp头部完成分包后下发客户端
利用rtp的序列号、时间戳，对接收数据进行丢包、乱序、重复的处理，增加了UDP的可靠性
维护rtp发送缓冲队列，达到足够帧数时开始定时发送，防止发送的不平滑及网络抖动的影响




1.熟悉C/C++开发，熟悉面向对象编程思想，熟悉常用的设计模式，熟悉STL，熟悉C++11;
2.熟悉Linux/UNIX操作系统，对进程/线程管理、IPC、资源竞争以及内存管理有一定了解；
3.掌握Socket网络编程，熟悉TCP/UDP，HTTP，SIP，RTSP，RTP等网络协议；
4熟悉Select、Epoll等I/O复用，熟悉libevent，muduo等网络库源码，libcurl的使用；
5.熟悉常用数据结构，以及基本的查找和排序算法，熟悉MySQL常用语句，能在项目中熟练使用；
6.熟悉Linux/Windows开发环境及常用命令，了解GDB，Cmake、Makefile，VisualStdio的使用；
7.了解音视频基础知识，PS，H264格式，FFmpeg。熟悉STM32及其外设，Freertos的原理和使用


喜欢阅读技术方面的书籍和博客：Effective c++，代码整洁之道、现代操作系统，Tcp/Ip详解，Linux多线程服务端编程等，喜欢研究开源项目：libevent，muduo，tinyhttp等。




