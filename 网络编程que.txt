send函数不能直接用“”“”应该用数组，字符指针
recv 函数加了最后一个参数，waitall后阻塞了，设置0正常运行
recv在对方掉线后，会解除阻塞状态然后返回0，select变可读
FD_ISSET（fd，&set）检查fd是否在set这个集合里面
select返回-1 可能是字符集为空
send函数在连接断开时返回-1
ser关闭fd后仍受到cli的消息，因为tcp全双工，此时ser不能写，cli能写所以ser能受到？？？？？？？？？？？？？？
！！！！！！if（ret = 0）赋值了，导致ret0，逻辑错误，尽量用const

在派生类对象中生成基类对象指针操作，容易出问题。改用了不相关的两个类正常
将fd_set fd_set 类型与变量同名，编译器一直报 应输入表达式错误，linux下能编译
连续send时 ，recv返回数量正确，但是打印只有前一个内容，send间加10ms延时正常

T* array[] 在指针数组中delete array[0]时出现.exe 已触发了一个断点。可能是释放指针内存错误，
改为array[0] = null，经检查是数组中的元素不是经new分配的动态内存，不能用delete

头文件包含出问题，相互包含导致？？？？？？？头文件不要互相包含，可以把头文件包含在cpp文件中，
函数实现放在cpp中，（头文件不能相互包含，类如需被外部使用定义需放在头文件，相互关联的两个类只能
放在同一个头文件中定义）

friend class ClientInfo;
typedef std::map<int, std::pair<ClientInfo*, int>> MAP;这两行调换顺序编译报错

客户端断开连接后，服务端recv一直可读，应该判断0或-1后直接关闭fd

将数据库结果row_[i]直接与“192.168”比较不行，得将结果赋值给string在和字面值比较正确

包含libcurl头文件，在工程中用#include "curl/curl.h"，用<>时错误
vs包含时选择文件夹里面看不到文件。
libcurl使用post时必须要有消息主体

用自己的debugprint会整个程序卡主，单独cout没问题
recv单词没接收完，会再次进入recv

当客户端bind一个port，第一次连接上退出后，处于4次挥手状态，该port被占用，在结束状态前再次运行程序所以会连接不上（为什么第二次不会阻塞在conn）
当客户端system时，因为是直接中断程序，所以服务端判断通信结束关闭了fd，所以客户端立刻运行能连接上
当处于port被占用，再次连接时conn立刻返回-1，成功时返回0，服务器不在线阻塞一会后返回-1

用libcurl终端卡主没有输出，经调试，仅仅是终端卡主了，程序仍在运行。卡主是因为用string，用数组不会卡主。
用http时，输出烫烫烫是字符串结尾没有\0结束符，cout会将未初始化也打印出来，一直到数组结尾（send时长度不加strlen+1时出现）。

多线程断点，发现窗口没有输出了
iocp客户端掉线时get函数返回0，错误码〖64〗-指定的网络名不再可用。 客户端正常关闭时，get返回1，接收数据量为0
打印遇到字符串结束符就不再输出后面的字符串了
当recv不及时，缓冲区会一直叠加，到下一次recv一起取出

recv中的buff最好进行初始化char head[1000]={0};这样打印不会有烫烫烫了，找到\0了

httppost的长度要对上才能解析出来
用postman，回复时send的字节数用了sizeof buff，导致字数对不上，应该用strlen+1，
mysql col=id处 用字符串表示id  用s% 如果用了d%id值变了

服务端关闭后 客户端再次连接使用的fd可能还是上次的，导致一直可读，应该判断connect的返回值，而且通过read的返回值也能判断是否-1














